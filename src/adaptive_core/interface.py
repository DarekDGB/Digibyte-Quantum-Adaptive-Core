# src/adaptive_core/interface.py

from __future__ import annotations

from typing import Any, Optional, Iterable, Dict, List

from .engine import AdaptiveEngine
from .threat_packet import ThreatPacket
from .models import RiskEvent, AdaptiveState, AdaptiveUpdateResult


class AdaptiveCoreInterface:
    """
    High-level interface for interacting with the DigiByte Quantum Adaptive Core.

    This is what other shield layers (Sentinel AI v2, DQSN v2, ADN v2,
    Guardian Wallet v2, Quantum Wallet Guard v2) should use instead of
    talking directly to the engine.

    Responsibilities:
      - Accept ThreatPacket objects from any layer
      - Accept feedback events (TRUE_POSITIVE, FALSE_POSITIVE, MISSED_ATTACK)
      - Accept wallet / app events from bridges (e.g. QWG via emit_adaptive_event)
      - Forward them into the AdaptiveEngine where appropriate
      - Expose a unified Immune Report and adaptive state for consumers
    """

    def __init__(self, engine: Optional[AdaptiveEngine] = None) -> None:
        # If no engine is provided, create a default one.
        self.engine: AdaptiveEngine = engine or AdaptiveEngine()

        # Raw adaptive events received from external layers (QWG, Guardian, etc.)
        # These are stored for diagnostics / future learning hooks.
        self.received_events: List[Dict[str, Any]] = []

    # ------------------------------------------------------------------ #
    # Inbound API from shield layers (ThreatPackets + feedback)
    # ------------------------------------------------------------------ #

    def submit_threat_packet(self, packet: ThreatPacket) -> None:
        """
        Submit a single ThreatPacket into the adaptive core.
        """
        self.engine.receive_threat_packet(packet)

    def submit_feedback_events(
        self,
        events: Iterable[RiskEvent],
    ) -> AdaptiveUpdateResult:
        """
        Submit labelled feedback events to the adaptive core so it can learn.
        """
        return self.engine.apply_learning(events)

    # ------------------------------------------------------------------ #
    # Inbound API from wallet bridges (QWG → Adaptive Core)
    # ------------------------------------------------------------------ #

    def handle_event(self, event: Dict[str, Any]) -> None:
        """
        Entry point used by external bridges, e.g. QWG's emit_adaptive_event.

        Expected minimal schema:
          - event_id:    str
          - action:      str  (e.g. "block", "delay", "warn", ...)
          - severity:    float (0.0 – 1.0)
          - fingerprint: str  (wallet / device fingerprint)

        Any extra keys (user_id, extra, source, ...) are accepted
        and preserved. On any error this function quietly returns –
        Adaptive Core must never break wallet logic upstream.
        """
        if not isinstance(event, dict):
            return

        try:
            # Normalise core fields
            event_id = str(event.get("event_id", "unknown"))
            action = str(event.get("action", "unknown"))
            severity = float(event.get("severity", 0.0))

            normalized: Dict[str, Any] = dict(event)
            normalized["event_id"] = event_id
            normalized["action"] = action
            normalized["severity"] = severity

            # Tag the source if not already present
            normalized.setdefault("source", "external")

            self.received_events.append(normalized)

            # NOTE (v0.1):
            #   We are not yet turning these into RiskEvents / learning signals.
            #   Future versions can:
            #     - derive feedback from wallet decisions
            #     - call engine.record_events(...) or apply_learning(...)
        except Exception:
            # Safety first — never blow up the caller.
            return

    def list_events(self) -> List[Dict[str, Any]]:
        """
        Return a shallow copy of all received wallet/app events.

        Useful for diagnostics, tests or higher-level dashboards.
        """
        return list(self.received_events)

    # ------------------------------------------------------------------ #
    # Read-only intelligence API
    # ------------------------------------------------------------------ #

    def get_immune_report(
        self,
        min_severity: int = 0,
        pattern_window: int = 20,
        trend_bucket: str = "hour",
        last_n: int = 5,
    ) -> dict[str, Any]:
        """
        Return the full structured immune report generated by the core.
        """
        return self.engine.generate_immune_report(
            min_severity=min_severity,
            pattern_window=pattern_window,
            trend_bucket=trend_bucket,
            last_n=last_n,
        )

    def get_immune_report_text(
        self,
        min_severity: int = 0,
        pattern_window: int = 20,
        trend_bucket: str = "hour",
        last_n: int = 5,
    ) -> str:
        """
        Convenience helper that returns only the human-readable text
        section of the immune report.
        """
        report = self.get_immune_report(
            min_severity=min_severity,
            pattern_window=pattern_window,
            trend_bucket=trend_bucket,
            last_n=last_n,
        )
        return report.get("text", "")

    def get_threat_insights_text(self, min_severity: int = 0) -> str:
        """
        Shortcut wrapper for the simpler threat_insights view.
        """
        return self.engine.threat_insights(min_severity=min_severity)

    def get_adaptive_state(self) -> AdaptiveState:
        """
        Return the current adaptive state (layer weights + global threshold).
        """
        return self.engine.state

    def get_last_update_metadata(self) -> dict[str, Any]:
        """
        Return metadata about last threat and last learning update.
        """
        return self.engine.get_last_update_metadata()
