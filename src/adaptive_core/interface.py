# src/adaptive_core/interface.py

from __future__ import annotations

from typing import Any, Optional, Iterable

from .engine import AdaptiveEngine
from .threat_packet import ThreatPacket
from .models import RiskEvent, AdaptiveState, AdaptiveUpdateResult


class AdaptiveCoreInterface:
    """
    High-level interface for interacting with the DigiByte Quantum Adaptive Core.

    This is what other shield layers (Sentinel AI v2, DQSN v2, ADN v2,
    Guardian Wallet v2, Quantum Wallet Guard v2) should use instead of
    talking directly to the engine.

    Responsibilities:
      - Accept ThreatPacket objects from any layer
      - Accept feedback events (TRUE_POSITIVE, FALSE_POSITIVE, MISSED_ATTACK)
      - Forward them into the AdaptiveEngine
      - Expose a unified Immune Report and adaptive state for consumers
    """

    def __init__(self, engine: Optional[AdaptiveEngine] = None) -> None:
        # If no engine is provided, create a default one.
        self.engine = engine or AdaptiveEngine()

    # ------------------------------------------------------------------ #
    # Inbound API from shield layers
    # ------------------------------------------------------------------ #

    def submit_threat_packet(self, packet: ThreatPacket) -> None:
        """
        Submit a single ThreatPacket into the adaptive core.

        Typical usage from other layers:

            interface.submit_threat_packet(
                ThreatPacket(
                    source_layer="sentinel_ai_v2",
                    threat_type="reorg_pattern",
                    severity=8,
                    description="Abnormal reorg pattern detected.",
                    block_height=1234567,
                    metadata={"score": 0.93},
                )
            )
        """
        self.engine.receive_threat_packet(packet)

    def submit_feedback_events(
        self,
        events: Iterable[RiskEvent],
    ) -> AdaptiveUpdateResult:
        """
        Submit labelled feedback events to the adaptive core so it can learn.

        Each RiskEvent carries:
            - which layer reported the risk
            - which threat / context it refers to
            - feedback type (TRUE_POSITIVE, FALSE_POSITIVE, MISSED_ATTACK)

        The engine will update layer weights and global thresholds and
        return an AdaptiveUpdateResult summary.
        """
        return self.engine.apply_learning(events)

    # ------------------------------------------------------------------ #
    # Read-only intelligence API
    # ------------------------------------------------------------------ #

    def get_immune_report(
        self,
        min_severity: int = 0,
        pattern_window: int = 20,
        trend_bucket: str = "hour",
        last_n: int = 5,
    ) -> dict[str, Any]:
        """
        Return the full structured immune report generated by the core.

        This is the main entry point for other layers to understand the
        current security posture and learned patterns.
        """
        return self.engine.generate_immune_report(
            min_severity=min_severity,
            pattern_window=pattern_window,
            trend_bucket=trend_bucket,
            last_n=last_n,
        )

    def get_immune_report_text(
        self,
        min_severity: int = 0,
        pattern_window: int = 20,
        trend_bucket: str = "hour",
        last_n: int = 5,
    ) -> str:
        """
        Convenience helper that returns only the human-readable text
        section of the immune report. Useful for logs, dashboards or
        debugging output.
        """
        report = self.get_immune_report(
            min_severity=min_severity,
            pattern_window=pattern_window,
            trend_bucket=trend_bucket,
            last_n=last_n,
        )
        return report.get("text", "")

    def get_threat_insights_text(self, min_severity: int = 0) -> str:
        """
        Shortcut wrapper for the simpler threat_insights view.
        """
        return self.engine.threat_insights(min_severity=min_severity)

    def get_adaptive_state(self) -> AdaptiveState:
        """
        Return the current adaptive state (layer weights + global threshold).
        Useful for debugging, dashboards or external monitoring.
        """
        return self.engine.state
